<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Ocean Cleanup Challenge</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #4682B4 100%);
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        /* Ocean Background Layers */
        .ocean-background { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; overflow: hidden; }
        .sky-layer { position: absolute; top: 0; left: 0; width: 100%; height: 40%; background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 50%, #87CEEB 100%); animation: skyFloat 20s ease-in-out infinite; }
        .far-sea-layer { position: absolute; top: 30%; left: 0; width: 100%; height: 70%; background: linear-gradient(180deg, #4682B4 0%, #2F4F4F 50%, #191970 100%); animation: farSeaFloat 15s ease-in-out infinite; }
        .mid-sea-layer { position: absolute; top: 50%; left: 0; width: 100%; height: 50%; background: linear-gradient(180deg, rgba(70,130,180,0.8) 0%, rgba(25,25,112,0.9) 100%); animation: midSeaFloat 12s ease-in-out infinite; }
        .near-water-layer { position: absolute; top: 70%; left: 0; width: 100%; height: 30%; background: linear-gradient(180deg, rgba(0,191,255,0.6) 0%, rgba(0,100,200,0.8) 100%); animation: nearWaterFloat 8s ease-in-out infinite; }
        .caustic-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background:
            radial-gradient(circle at 20% 30%, rgba(255,255,255,0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 60%, rgba(255,255,255,0.08) 0%, transparent 50%),
            radial-gradient(circle at 40% 80%, rgba(255,255,255,0.06) 0%, transparent 50%);
            animation: causticShimmer 6s ease-in-out infinite; pointer-events: none; }

        @keyframes skyFloat { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-5px)} }
        @keyframes farSeaFloat { 0%,100%{transform:translateY(0) translateX(0)} 33%{transform:translateY(-3px) translateX(2px)} 66%{transform:translateY(2px) translateX(-1px)} }
        @keyframes midSeaFloat { 0%,100%{transform:translateY(0) translateX(0)} 50%{transform:translateY(-8px) translateX(3px)} }
        @keyframes nearWaterFloat { 0%,100%{transform:translateY(0) translateX(0)} 25%{transform:translateY(-12px) translateX(-4px)} 75%{transform:translateY(8px) translateX(2px)} }
        @keyframes causticShimmer { 0%,100%{opacity:0.3;transform:scale(1) rotate(0)} 33%{opacity:0.5;transform:scale(1.1) rotate(2deg)} 66%{opacity:0.2;transform:scale(0.9) rotate(-1deg)} }

        /* Modal Styles */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display:flex; justify-content:center; align-items:center; z-index:1000; }
        .modal-content { background: white; padding: 2rem; border-radius: 20px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 400px; width: 90%; }
        .grade-button { background: linear-gradient(45deg,#4CAF50,#45a049); color:white; border:none; padding:15px 30px; margin:10px; border-radius:10px; font-size:18px; cursor:pointer; transition: transform .2s; }
        .grade-button:hover { transform: scale(1.05); }

        /* Game Container */
        .game-container { width: 100%; height: 100vh; position: relative; display: none; }

        /* Header UI */
        .header { position:absolute; top:0; left:0; right:0; height:80px; background: rgba(0,0,0,0.1); display:flex; justify-content:space-between; align-items:center; padding:0 20px; z-index:100; }
        .timer-container { display:flex; align-items:center; gap:15px; }
        .timer { background: rgba(255,255,255,0.9); padding:10px 20px; border-radius:25px; font-size:24px; font-weight:bold; color:#333; box-shadow:0 4px 15px rgba(0,0,0,0.2); transition: all .3s ease; }
        .stop-button { background: linear-gradient(45deg,#FF6B6B,#FF8E8E); color:white; border:none; padding:10px 15px; border-radius:20px; font-size:16px; font-weight:bold; cursor:pointer; box-shadow:0 4px 15px rgba(0,0,0,0.2); transition: all .3s ease; min-width:80px; }
        .stop-button:hover { transform: scale(1.05); box-shadow:0 6px 20px rgba(255,107,107,0.4); }
        .team-info { background: rgba(255,255,255,0.9); padding:10px 15px; border-radius:15px; min-width:200px; }
        .team-left { background: linear-gradient(45deg,#FF6B6B,#FF8E8E); color:white; }
        .team-right { background: linear-gradient(45deg,#4ECDC4,#6FDDDD); color:white; }
        .player-name { font-weight:bold; font-size:16px; }
        .player-score { font-size:14px; opacity:0.9; }

        /* Ocean Panels */
        .ocean-container { position:absolute; top:80px; left:0; right:0; bottom:0; display:flex; }
        .ocean-panel { flex:1; position:relative; background:transparent; overflow:hidden; transition: all .3s ease; }

        /* Particle Systems */
        .bubble-container { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:1; }
        .bubble { position:absolute; background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.1) 70%, transparent 100%); border-radius:50%; animation: bubbleFloat 8s linear infinite; }
        .sparkle { position:absolute; width:8px; height:8px; background: radial-gradient(circle,#FFD700 0%, transparent 70%); border-radius:50%; animation: sparkleEffect 1s ease-out forwards; pointer-events:none; z-index:1000; }
        .confetti { position:absolute; width:6px; height:6px; animation: confettiFall 3s ease-out forwards; pointer-events:none; z-index:1000; }
        .success-burst { position:absolute; width:60px; height:60px; border-radius:50%; background: radial-gradient(circle, rgba(76,175,80,0.6) 0%, transparent 70%); animation: successBurst 0.6s ease-out forwards; pointer-events:none; z-index:999; }

        @keyframes bubbleFloat { 0%{transform:translateY(100vh) scale(0);opacity:0} 10%{opacity:1;transform:translateY(90vh) scale(1)} 90%{opacity:1;transform:translateY(-10vh) scale(1)} 100%{transform:translateY(-20vh) scale(0);opacity:0} }
        @keyframes sparkleEffect { 0%{transform:scale(0) rotate(0);opacity:1} 50%{transform:scale(1.5) rotate(180deg);opacity:0.8} 100%{transform:scale(0) rotate(360deg);opacity:0} }
        @keyframes confettiFall { 0%{transform:translateY(-20px) rotate(0);opacity:1} 100%{transform:translateY(100vh) rotate(720deg);opacity:0} }
        @keyframes successBurst { 0%{transform:scale(0);opacity:0.8} 50%{transform:scale(1.2);opacity:0.4} 100%{transform:scale(2);opacity:0} }

        .ocean-panel.flash-red { background: rgba(244,67,54,0.3); animation: flashRed 0.5s ease-out; }
        @keyframes flashRed { 0%{background:rgba(244,67,54,0.6)} 100%{background:linear-gradient(180deg,#87CEEB 0%, #4682B4 50%, #191970 100%)} }

        .divider { width:4px; background: linear-gradient(180deg,#FFD700,#FFA500); box-shadow:0 0 20px rgba(255,215,0,0.5); }

        /* Bins */
        .bins-container { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); display:flex; gap:20px; }
        .bin { width:80px; height:100px; border-radius:15px; display:flex; flex-direction:column; align-items:center; justify-content:center; cursor:pointer; transition: all .3s ease; border:3px solid transparent; }
        .recycling-bin { background: linear-gradient(145deg,#4CAF50,#45a049); color:white; }
        .garbage-bin { background: linear-gradient(145deg,#757575,#616161); color:white; }
        .bin.hover-glow { box-shadow:0 0 30px currentColor, inset 0 0 20px rgba(255,255,255,0.3); transform:scale(1.15); border:3px solid rgba(255,255,255,0.8); }
        .bin.correct-hover { box-shadow:0 0 40px #4CAF50, inset 0 0 25px rgba(76,175,80,0.4); border:3px solid #4CAF50; animation: correctPulse .5s ease-in-out; }
        .bin.magnetism { animation: magnetPull .3s ease-out; }
        @keyframes correctPulse { 0%,100%{transform:scale(1.1)} 50%{transform:scale(1.2)} }
        @keyframes magnetPull { 0%{transform:scale(1)} 50%{transform:scale(1.05)} 100%{transform:scale(1.1)} }
        .bin-icon { font-size:24px; margin-bottom:5px; }
        .bin-label { font-size:12px; font-weight:bold; }

        /* Game Objects */
        .game-object { position:absolute; cursor:grab; transition: transform .12s ease; user-select:none; will-change:transform, opacity; }
        .game-object:hover { transform: scale(1.1); }
        .game-object.dragging { cursor:grabbing; z-index:1000; transform:scale(1.2); filter: drop-shadow(0 8px 25px rgba(0,0,0,0.4)); animation: none; }
        .game-object.correct-outline { outline:3px solid #4CAF50; outline-offset:2px; box-shadow:0 0 15px rgba(76,175,80,0.6); }
        .game-object.magnetic-pull { animation: magneticPull .2s ease-out; }
        @keyframes magneticPull { 0%{transform:scale(1)} 100%{transform:scale(1.1)} }
        .plastic-item, .trash-item, .sea-creature { background:transparent; border:none; padding:8px; font-size:24px; }
        .sea-creature { cursor:not-allowed; transition: all .3s ease; }
        .sea-creature.schooling { animation: schoolingPath 50s ease-in-out infinite; }
        .sea-creature.darting { animation: dartingMotion .8s ease-out; }
        @keyframes schoolingPath { 0%,100%{transform:translateX(0) translateY(0) rotate(0)} 25%{transform:translateX(0.3px) translateY(-0.2px) rotate(.05deg)} 50%{transform:translateX(0.5px) translateY(0.2px) rotate(-.05deg)} 75%{transform:translateX(0.3px) translateY(0.3px) rotate(.05deg)} }
        @keyframes dartingMotion { 0%{transform:translateX(0) translateY(0)} 30%{transform:translateX(-3px) translateY(-2px)} 60%{transform:translateX(2px) translateY(3px)} 100%{transform:translateX(0) translateY(0)} }

        /* Slower, mostly vertical fall for emoji-like items (final version) */
        @keyframes emojiFall {
            0% { transform: translateY(-15vh) translateX(0); opacity: 0; }
            3% { opacity: 1; }
            97% { transform: translateY(calc(100vh - 220px)) translateX(var(--drift-x, 0px)); opacity: 1; }
            100% { transform: translateY(calc(100vh - 200px)) translateX(var(--drift-x, 0px)); opacity: 0; }
        }

        /* Class to apply to emoji/game-object items for a very slow, near-vertical descent */
        .emoji-fall { animation: emojiFall 60s linear infinite; --drift-x: 0px; }
        /* Keep .natural-fall compatibility but point it to the same gentle behavior */
        .natural-fall { animation: emojiFall 60s linear infinite; --drift-x: 0px; }

        @keyframes gentleRotate { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }
        .gentle-rotate { animation: gentleRotate 20s linear infinite; }

        @keyframes avoidCursor { 0%{transform:translate(0,0)} 50%{transform:translate(var(--avoid-x,0), var(--avoid-y,0))} 100%{transform:translate(0,0)} }
        @keyframes currentBurst { 0%{transform:translateX(0)} 100%{transform:translateX(var(--burst-distance,50px))} }
        .avoiding { animation: avoidCursor 1s ease-out; }
        .current-burst { animation: currentBurst 2s ease-out; }

        /* Countdown / Overlays / UI (unchanged) */
        .countdown { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 120px; font-weight: bold; color: #FFD700; text-shadow: 3px 3px 6px rgba(0,0,0,0.5); z-index: 500; display: none; }
        .next-players-container, .name-shuffle-container { display:none; position:fixed; top:0; left:0; width:100%; height:100%; z-index:1000; justify-content:center; align-items:center; flex-direction:column; }
        .name-shuffle-container { background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(25,25,112,0.9)); z-index:1001; }
        .shuffle-title { color:#FFD700; font-size:42px; font-weight:bold; margin-bottom:60px; text-align:center; text-shadow:2px 2px 8px rgba(0,0,0,0.7); animation: shuffleTitlePulse 1.5s ease-in-out infinite alternate; }
        @keyframes shuffleTitlePulse { 0%{transform:scale(1); text-shadow:2px 2px 8px rgba(255,215,0,0.3)} 100%{transform:scale(1.05); text-shadow:2px 2px 15px rgba(255,215,0,0.8)} }
        .shuffle-names { display:flex; gap:120px; margin-bottom:60px; }
        .shuffle-player { text-align:center; min-width:350px; }
        .shuffle-label { color:#87CEEB; font-size:24px; font-weight:bold; margin-bottom:20px; text-shadow:1px 1px 4px rgba(0,0,0,0.5); }
        .shuffle-name { background: linear-gradient(45deg,#FF6B6B,#4ECDC4); color:white; padding:25px 30px; border-radius:20px; font-size:22px; font-weight:bold; min-height:60px; display:flex; align-items:center; justify-content:center; box-shadow:0 8px 25px rgba(0,0,0,0.3); animation:shuffleFlicker 0.1s ease-in-out infinite; border:3px solid rgba(255,255,255,0.3); }
        @keyframes shuffleFlicker { 0%{transform:scale(1)} 50%{transform:scale(1.02)} 100%{transform:scale(1)} }
        .shuffle-name.selected { animation: shuffleSelected .8s ease-out; background:linear-gradient(45deg,#4CAF50,#45a049); border:3px solid #FFD700; box-shadow:0 0 30px rgba(76,175,80,0.6); }
        @keyframes shuffleSelected { 0%{transform:scale(1)} 50%{transform:scale(1.15)} 100%{transform:scale(1.05)} }
        .shuffle-progress { width:400px; height:8px; background: rgba(255,255,255,0.2); border-radius:4px; overflow:hidden; margin-top:20px; }
        .shuffle-bar { height:100%; background: linear-gradient(90deg,#FFD700,#FFA500); width:0%; border-radius:4px; transition: width .1s ease; box-shadow:0 0 10px rgba(255,215,0,0.5); }
        .shuffle-timer { color:#FFD700; font-size:36px; font-weight:bold; margin-top:20px; text-shadow:2px 2px 8px rgba(0,0,0,0.7); }
        .next-players-title { color:white; font-size:36px; margin-bottom:40px; text-align:center; }
        .next-players-names { display:flex; gap:80px; margin-bottom:40px; }
        .next-player { background: linear-gradient(45deg,#FF6B6B,#4ECDC4); color:white; padding:30px 40px; border-radius:20px; font-size:28px; font-weight:bold; text-align:center; min-width:300px; animation: playerPulse 1s ease-in-out infinite alternate; }
        @keyframes playerPulse { 0%{transform:scale(1)} 100%{transform:scale(1.05)} }
        .next-countdown { color:#FFD700; font-size:48px; font-weight:bold; text-shadow:2px 2px 4px rgba(0,0,0,0.5); }
        .results-modal { display:none; }
        .leaderboard { margin:20px 0; text-align:left; }
        .leaderboard-item { padding:10px; background:#f0f0f0; margin:5px 0; border-radius:8px; display:flex; justify-content:space-between; }
        .high-contrast { filter: contrast(150%) brightness(120%); }
        .accessibility-toggle { position: fixed; top:10px; right:10px; background: rgba(0,0,0,0.7); color:white; border:none; padding:10px; border-radius:5px; cursor:pointer; z-index:1001; }

        /* Responsive */
        @media (max-width:768px) {
            .header { height:60px; padding:0 10px; }
            .timer { font-size:18px; padding:8px 15px; }
            .team-info { min-width:150px; padding:8px 12px; }
            .bin { width:60px; height:80px; }
            .countdown { font-size:80px; }
            .next-players-names { flex-direction:column; gap:30px; }
            .next-player { min-width:250px; font-size:24px; padding:25px 30px; }
        }
    </style>
</head>
<body>

    <!-- Grade Selection Modal -->
    <div id="gradeModal" class="modal">
        <div class="modal-content">
            <h2>选择年级 / Select Grade Level</h2>
            <p>Choose your grade to start the Ocean Cleanup Challenge!</p>
            <button class="grade-button" onclick="selectGrade(10)">Grade 10 (17 students)</button>
            <button class="grade-button" onclick="selectGrade(11)">Grade 11 (14 students)</button>
            <button class="grade-button" onclick="selectGrade(12)">Grade 12 (13 students)</button>
        </div>
    </div>

    <!-- Next Players Display -->
    <div id="nextPlayersContainer" class="next-players-container">
        <div class="next-players-title">下一轮选手 / Next Players</div>
        <div class="next-players-names">
            <div class="next-player" id="nextPlayerLeft">Player 1</div>
            <div class="next-player" id="nextPlayerRight">Player 2</div>
        </div>
        <div class="next-countdown" id="nextCountdown">10</div>
    </div>

    <!-- Name Shuffling Display -->
    <div id="nameShuffleContainer" class="name-shuffle-container">
        <div class="shuffle-title">🎲 选择选手中... / Selecting Players... 🎲</div>
        <div class="shuffle-names">
            <div class="shuffle-player" id="shufflePlayerLeft">
                <div class="shuffle-label">左队 / Left Team</div>
                <div class="shuffle-name" id="shuffleNameLeft">---</div>
            </div>
            <div class="shuffle-player" id="shufflePlayerRight">
                <div class="shuffle-label">右队 / Right Team</div>
                <div class="shuffle-name" id="shuffleNameRight">---</div>
            </div>
        </div>
        <div class="shuffle-progress"><div class="shuffle-bar" id="shuffleBar"></div></div>
        <div class="shuffle-timer" id="shuffleTimer">5</div>
    </div>

    <!-- Ocean Background -->
    <div class="ocean-background">
        <div class="sky-layer"></div>
        <div class="far-sea-layer"></div>
        <div class="mid-sea-layer"></div>
        <div class="near-water-layer"></div>
        <div class="caustic-overlay"></div>
    </div>

    <!-- Game Container -->
    <div id="gameContainer" class="game-container">

        <!-- Header UI -->
        <div class="header">
            <div class="team-info team-left">
                <div class="player-name" id="leftPlayerName">Left Team</div>
                <div class="player-score" id="leftPlayerScore">Score: 0</div>
            </div>

            <div class="timer-container">
                <div class="timer" id="gameTimer">2:00</div>
                <button class="stop-button" id="stopButton" onclick="toggleGamePause()">⏸️ STOP</button>
            </div>

            <div class="team-info team-right">
                <div class="player-name" id="rightPlayerName">Right Team</div>
                <div class="player-score" id="rightPlayerScore">Score: 0</div>
            </div>
        </div>

        <!-- Ocean Container -->
        <div class="ocean-container">
            <!-- Left Ocean Panel -->
            <div class="ocean-panel" id="leftOcean">
                <div class="bubble-container" id="leftBubbles"></div>
                <div class="bins-container">
                    <div class="bin recycling-bin" data-type="recycling" data-team="left">
                        <div class="bin-icon">♻️</div>
                        <div class="bin-label">Recycling</div>
                    </div>
                    <div class="bin garbage-bin" data-type="garbage" data-team="left">
                        <div class="bin-icon">🗑️</div>
                        <div class="bin-label">Garbage</div>
                    </div>
                </div>
            </div>

            <!-- Central Divider -->
            <div class="divider"></div>

            <!-- Right Ocean Panel -->
            <div class="ocean-panel" id="rightOcean">
                <div class="bubble-container" id="rightBubbles"></div>
                <div class="bins-container">
                    <div class="bin recycling-bin" data-type="recycling" data-team="right">
                        <div class="bin-icon">♻️</div>
                        <div class="bin-label">Recycling</div>
                    </div>
                    <div class="bin garbage-bin" data-type="garbage" data-team="right">
                        <div class="bin-icon">🗑️</div>
                        <div class="bin-label">Garbage</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Countdown Display -->
    <div id="countdown" class="countdown">3</div>

    <!-- Results Modal -->
    <div id="resultsModal" class="modal results-modal">
        <div class="modal-content">
            <h2>本轮结束 / Round Complete!</h2>
            <div id="roundResults"></div>
            <div class="leaderboard">
                <h3>排行榜 / Leaderboard</h3>
                <div id="leaderboardList"></div>
            </div>
        </div>
    </div>

    <!-- Accessibility Toggle -->
    <button class="accessibility-toggle" id="accessibilityToggle" aria-pressed="false">Contrast</button>

    <!-- Core game scripts and helpers -->
    <script>
        // Helper script: automatically tag emoji-like elements so they use the slow near-vertical fall.
        (function () {
            // Simple emoji detection (covers many common emoji ranges)
            const emojiRegex = /[\u{1F300}-\u{1F6FF}\u{1F900}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/u;

            function applyEmojiFallToNode(node) {
                if (!(node instanceof HTMLElement)) return;
                // Skip if already handled
                if (node.classList.contains('emoji-fall') || node.classList.contains('natural-fall')) return;

                // If element explicitly flagged as emoji via data attribute
                if (node.dataset && (node.dataset.emoji === 'true' || node.dataset.emoji === 'emoji')) {
                    node.classList.add('emoji-fall', 'game-object');
                    return;
                }

                // If text contains emoji characters, apply the class
                try {
                    const txt = (node.textContent || '').trim();
                    if (txt && emojiRegex.test(txt)) {
                        node.classList.add('emoji-fall', 'game-object');
                        // set zero drift by default for strict vertical motion
                        node.style.setProperty('--drift-x', '0px');
                    }
                } catch (e) {
                    // ignore read errors
                }
            }

            function scanExisting() {
                // Add to all existing elements that look like emoji items
                document.querySelectorAll('.game-object, [data-emoji], .emoji, .emoji-item').forEach(el => applyEmojiFallToNode(el));
                // Also scan any elements that contain emoji characters
                document.querySelectorAll('body *:not(script):not(style)').forEach(el => {
                    applyEmojiFallToNode(el);
                });
            }

            const observer = new MutationObserver(muts => {
                for (const m of muts) {
                    if (m.type === 'childList') {
                        m.addedNodes.forEach(n => {
                            if (n.nodeType !== Node.ELEMENT_NODE) return;
                            applyEmojiFallToNode(n);
                            if (n.querySelectorAll) n.querySelectorAll('*').forEach(c => applyEmojiFallToNode(c));
                        });
                    } else if (m.type === 'attributes' && m.target) {
                        applyEmojiFallToNode(m.target);
                    }
                }
            });

            observer.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['data-emoji','class'] });

            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', scanExisting);
            else scanExisting();

            // Expose a helper for your game code to mark created elements explicitly
            window.markAsEmojiFall = function (el, opts) {
                if (!el) return;
                el.classList.add('emoji-fall', 'game-object');
                const drift = opts && typeof opts.driftX !== 'undefined' ? opts.driftX : 0;
                el.style.setProperty('--drift-x', (drift) + 'px');
            };

            // Accessibility toggle
            const accBtn = document.getElementById('accessibilityToggle');
            if (accBtn) {
                accBtn.addEventListener('click', () => {
                    document.body.classList.toggle('high-contrast');
                    const pressed = document.body.classList.contains('high-contrast');
                    accBtn.setAttribute('aria-pressed', pressed ? 'true' : 'false');
                });
            }
        })();
    </script>

    <!-- Your main game script should come after the helpers above.
         To ensure slow near-vertical fall for new emoji objects created by your code:
           - call markAsEmojiFall(element) OR
           - add class="game-object emoji-fall" to the element OR
           - set data-emoji="true" on the element before appending it.
         Drift is set to 0px by default; if you want a tiny side-to-side drift, pass markAsEmojiFall(el, { driftX: 1 }) -->
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean Cleanup Challenge</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #4682B4 100%);
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        /* Ocean Background Layers */
        .ocean-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .sky-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40%;
            background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 50%, #87CEEB 100%);
            animation: skyFloat 20s ease-in-out infinite;
        }

        .far-sea-layer {
            position: absolute;
            top: 30%;
            left: 0;
            width: 100%;
            height: 70%;
            background: linear-gradient(180deg, #4682B4 0%, #2F4F4F 50%, #191970 100%);
            animation: farSeaFloat 15s ease-in-out infinite;
        }

        .mid-sea-layer {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(180deg, rgba(70, 130, 180, 0.8) 0%, rgba(25, 25, 112, 0.9) 100%);
            animation: midSeaFloat 12s ease-in-out infinite;
        }

        .near-water-layer {
            position: absolute;
            top: 70%;
            left: 0;
            width: 100%;
            height: 30%;
            background: linear-gradient(180deg, rgba(0, 191, 255, 0.6) 0%, rgba(0, 100, 200, 0.8) 100%);
            animation: nearWaterFloat 8s ease-in-out infinite;
        }

        .caustic-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 60%, rgba(255, 255, 255, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(255, 255, 255, 0.06) 0%, transparent 50%);
            animation: causticShimmer 6s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes skyFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        @keyframes farSeaFloat {
            0%, 100% { transform: translateY(0px) translateX(0px); }
            33% { transform: translateY(-3px) translateX(2px); }
            66% { transform: translateY(2px) translateX(-1px); }
        }

        @keyframes midSeaFloat {
            0%, 100% { transform: translateY(0px) translateX(0px); }
            50% { transform: translateY(-8px) translateX(3px); }
        }

        @keyframes nearWaterFloat {
            0%, 100% { transform: translateY(0px) translateX(0px); }
            25% { transform: translateY(-12px) translateX(-4px); }
            75% { transform: translateY(8px) translateX(2px); }
        }

        @keyframes causticShimmer {
            0%, 100% { opacity: 0.3; transform: scale(1) rotate(0deg); }
            33% { opacity: 0.5; transform: scale(1.1) rotate(2deg); }
            66% { opacity: 0.2; transform: scale(0.9) rotate(-1deg); }
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .grade-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 10px;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .grade-button:hover {
            transform: scale(1.05);
        }

        /* Game Container */
        .game-container {
            width: 100%;
            height: 100vh;
            position: relative;
            display: none;
        }

        /* Header UI */
        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            z-index: 100;
        }

        .timer-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .timer {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .stop-button {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .stop-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .stop-button.stopped {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .timer.warning {
            background: rgba(255, 193, 7, 0.9);
            animation: pulse 1s ease-in-out infinite;
        }

        .timer.critical {
            background: rgba(244, 67, 54, 0.9);
            color: white;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .team-info {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 15px;
            min-width: 200px;
        }

        .team-left {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
            color: white;
        }

        .team-right {
            background: linear-gradient(45deg, #4ECDC4, #6FDDDD);
            color: white;
        }

        .player-name {
            font-weight: bold;
            font-size: 16px;
        }

        .player-score {
            font-size: 14px;
            opacity: 0.9;
        }

        /* Ocean Panels */
        .ocean-container {
            position: absolute;
            top: 80px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
        }

        .ocean-panel {
            flex: 1;
            position: relative;
            background: transparent;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* Particle Systems */
        .bubble-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .bubble {
            position: absolute;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0.1) 70%, transparent 100%);
            border-radius: 50%;
            animation: bubbleFloat 8s linear infinite;
        }

        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #FFD700 0%, transparent 70%);
            border-radius: 50%;
            animation: sparkleEffect 1s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }

        .confetti {
            position: absolute;
            width: 6px;
            height: 6px;
            animation: confettiFall 3s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }

        .success-burst {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(76, 175, 80, 0.6) 0%, transparent 70%);
            animation: successBurst 0.6s ease-out forwards;
            pointer-events: none;
            z-index: 999;
        }

        @keyframes bubbleFloat {
            0% {
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) scale(1);
            }
            90% {
                opacity: 1;
                transform: translateY(-10vh) scale(1);
            }
            100% {
                transform: translateY(-20vh) scale(0);
                opacity: 0;
            }
        }

        @keyframes sparkleEffect {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(180deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-20px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        @keyframes successBurst {
            0% {
                transform: scale(0);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.4;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .ocean-panel.flash-red {
            background: rgba(244, 67, 54, 0.3);
            animation: flashRed 0.5s ease-out;
        }

        @keyframes flashRed {
            0% { background: rgba(244, 67, 54, 0.6); }
            100% { background: linear-gradient(180deg, #87CEEB 0%, #4682B4 50%, #191970 100%); }
        }

        .divider {
            width: 4px;
            background: linear-gradient(180deg, #FFD700, #FFA500);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        /* Bins */
        .bins-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }

        .bin {
            width: 80px;
            height: 100px;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .recycling-bin {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
        }

        .garbage-bin {
            background: linear-gradient(145deg, #757575, #616161);
            color: white;
        }

        .bin.hover-glow {
            box-shadow: 0 0 30px currentColor, inset 0 0 20px rgba(255, 255, 255, 0.3);
            transform: scale(1.15);
            border: 3px solid rgba(255, 255, 255, 0.8);
        }

        .bin.correct-hover {
            box-shadow: 0 0 40px #4CAF50, inset 0 0 25px rgba(76, 175, 80, 0.4);
            border: 3px solid #4CAF50;
            animation: correctPulse 0.5s ease-in-out;
        }

        .bin.magnetism {
            animation: magnetPull 0.3s ease-out;
        }

        @keyframes correctPulse {
            0%, 100% { transform: scale(1.1); }
            50% { transform: scale(1.2); }
        }

        @keyframes magnetPull {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1.1); }
        }

        .bin-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .bin-label {
            font-size: 12px;
            font-weight: bold;
        }

        /* Game Objects */
        .game-object {
            position: absolute;
            cursor: grab;
            transition: transform 0.2s ease;
            user-select: none;
        }

        .game-object:hover {
            transform: scale(1.1);
        }

        .game-object.dragging {
            cursor: grabbing;
            z-index: 1000;
            transform: scale(1.2);
            filter: drop-shadow(0 8px 25px rgba(0, 0, 0, 0.4));
            animation: none;
        }

        .game-object.correct-outline {
            outline: 3px solid #4CAF50;
            outline-offset: 2px;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
        }

        .game-object.magnetic-pull {
            animation: magneticPull 0.2s ease-out;
        }

        @keyframes magneticPull {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
        }

        .plastic-item {
            background: transparent;
            border: none;
            padding: 8px;
            font-size: 24px;
        }

        .trash-item {
            background: transparent;
            border: none;
            padding: 8px;
            font-size: 24px;
        }

        .sea-creature {
            background: transparent;
            font-size: 24px;
            cursor: not-allowed;
            transition: all 0.3s ease;
        }

        .sea-creature.schooling {
            animation: schoolingPath 50s ease-in-out infinite;
        }

        .sea-creature.darting {
            animation: dartingMotion 0.8s ease-out;
        }

        @keyframes schoolingPath {
            0%, 100% { 
                transform: translateX(0px) translateY(0px) rotate(0deg); 
            }
            25% { 
                transform: translateX(0.3px) translateY(-0.2px) rotate(0.05deg); 
            }
            50% { 
                transform: translateX(0.5px) translateY(0.2px) rotate(-0.05deg); 
            }
            75% { 
                transform: translateX(0.3px) translateY(0.3px) rotate(0.05deg); 
            }
        }

        @keyframes dartingMotion {
            0% { 
                transform: translateX(0px) translateY(0px); 
            }
            30% { 
                transform: translateX(-3px) translateY(-2px); 
            }
            60% { 
                transform: translateX(2px) translateY(3px); 
            }
            100% { 
                transform: translateX(0px) translateY(0px); 
            }
        }

        /* Natural Fall and Float Animation */
        @keyframes naturalFall {
            0% { 
                transform: translateY(-50px) translateX(0px);
                opacity: 0;
            }
            5% {
                opacity: 1;
            }
            95% { 
                transform: translateY(calc(100vh - 350px)) translateX(var(--drift-x, 0px));
                opacity: 1;
            }
            100% { 
                transform: translateY(calc(100vh - 300px)) translateX(var(--drift-x, 0px));
                opacity: 0;
            }
        }

        @keyframes gentleRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .natural-fall {
            animation: naturalFall 60s ease-in-out infinite;
            --drift-x: 0px;
        }

        .gentle-rotate {
            animation: gentleRotate 20s linear infinite;
        }

        @keyframes avoidCursor {
            0% { transform: translate(0, 0); }
            50% { transform: translate(var(--avoid-x, 0), var(--avoid-y, 0)); }
            100% { transform: translate(0, 0); }
        }

        @keyframes currentBurst {
            0% { transform: translateX(0px); }
            100% { transform: translateX(var(--burst-distance, 50px)); }
        }



        .avoiding {
            animation: avoidCursor 1s ease-out;
        }

        .current-burst {
            animation: currentBurst 2s ease-out;
        }

        /* Countdown */
        .countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            z-index: 500;
            display: none;
        }

        /* Next Players Display */
        .next-players-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        /* Name Shuffling Display */
        .name-shuffle-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(25, 25, 112, 0.9));
            z-index: 1001;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .shuffle-title {
            color: #FFD700;
            font-size: 42px;
            font-weight: bold;
            margin-bottom: 60px;
            text-align: center;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
            animation: shuffleTitlePulse 1.5s ease-in-out infinite alternate;
        }

        @keyframes shuffleTitlePulse {
            0% { transform: scale(1); text-shadow: 2px 2px 8px rgba(255, 215, 0, 0.3); }
            100% { transform: scale(1.05); text-shadow: 2px 2px 15px rgba(255, 215, 0, 0.8); }
        }

        .shuffle-names {
            display: flex;
            gap: 120px;
            margin-bottom: 60px;
        }

        .shuffle-player {
            text-align: center;
            min-width: 350px;
        }

        .shuffle-label {
            color: #87CEEB;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);
        }

        .shuffle-name {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            padding: 25px 30px;
            border-radius: 20px;
            font-size: 22px;
            font-weight: bold;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            animation: shuffleFlicker 0.1s ease-in-out infinite;
            border: 3px solid rgba(255, 255, 255, 0.3);
        }

        @keyframes shuffleFlicker {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .shuffle-name.selected {
            animation: shuffleSelected 0.8s ease-out;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: 3px solid #FFD700;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
        }

        @keyframes shuffleSelected {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1.05); }
        }

        .shuffle-progress {
            width: 400px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 20px;
        }

        .shuffle-bar {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            width: 0%;
            border-radius: 4px;
            transition: width 0.1s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .shuffle-timer {
            color: #FFD700;
            font-size: 36px;
            font-weight: bold;
            margin-top: 20px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
        }

        .next-players-title {
            color: white;
            font-size: 36px;
            margin-bottom: 40px;
            text-align: center;
        }

        .next-players-names {
            display: flex;
            gap: 80px;
            margin-bottom: 40px;
        }

        .next-player {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            padding: 30px 40px;
            border-radius: 20px;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            min-width: 300px;
            animation: playerPulse 1s ease-in-out infinite alternate;
        }

        @keyframes playerPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        .next-countdown {
            color: #FFD700;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Results Modal */
        .results-modal {
            display: none;
        }

        .leaderboard {
            margin: 20px 0;
            text-align: left;
        }

        .leaderboard-item {
            padding: 10px;
            background: #f0f0f0;
            margin: 5px 0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
        }

        /* Accessibility */
        .high-contrast {
            filter: contrast(150%) brightness(120%);
        }

        .accessibility-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1001;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                height: 60px;
                padding: 0 10px;
            }
            
            .timer {
                font-size: 18px;
                padding: 8px 15px;
            }
            
            .team-info {
                min-width: 150px;
                padding: 8px 12px;
            }
            
            .bin {
                width: 60px;
                height: 80px;
            }
            
            .countdown {
                font-size: 80px;
            }

            .next-players-names {
                flex-direction: column;
                gap: 30px;
            }

            .next-player {
                min-width: 250px;
                font-size: 24px;
                padding: 25px 30px;
            }
        }
    </style>
</head>
<body>


    <!-- Grade Selection Modal -->
    <div id="gradeModal" class="modal">
        <div class="modal-content">
            <h2>选择年级 / Select Grade Level</h2>
            <p>Choose your grade to start the Ocean Cleanup Challenge!</p>
            <button class="grade-button" onclick="selectGrade(10)">Grade 10 (17 students)</button>
            <button class="grade-button" onclick="selectGrade(11)">Grade 11 (14 students)</button>
            <button class="grade-button" onclick="selectGrade(12)">Grade 12 (13 students)</button>
        </div>
    </div>



    <!-- Next Players Display -->
    <div id="nextPlayersContainer" class="next-players-container">
        <div class="next-players-title">下一轮选手 / Next Players</div>
        <div class="next-players-names">
            <div class="next-player" id="nextPlayerLeft">Player 1</div>
            <div class="next-player" id="nextPlayerRight">Player 2</div>
        </div>
        <div class="next-countdown" id="nextCountdown">10</div>
    </div>

    <!-- Name Shuffling Display -->
    <div id="nameShuffleContainer" class="name-shuffle-container">
        <div class="shuffle-title">🎲 选择选手中... / Selecting Players... 🎲</div>
        <div class="shuffle-names">
            <div class="shuffle-player" id="shufflePlayerLeft">
                <div class="shuffle-label">左队 / Left Team</div>
                <div class="shuffle-name" id="shuffleNameLeft">---</div>
            </div>
            <div class="shuffle-player" id="shufflePlayerRight">
                <div class="shuffle-label">右队 / Right Team</div>
                <div class="shuffle-name" id="shuffleNameRight">---</div>
            </div>
        </div>
        <div class="shuffle-progress">
            <div class="shuffle-bar" id="shuffleBar"></div>
        </div>
        <div class="shuffle-timer" id="shuffleTimer">5</div>
    </div>

    <!-- Ocean Background -->
    <div class="ocean-background">
        <div class="sky-layer"></div>
        <div class="far-sea-layer"></div>
        <div class="mid-sea-layer"></div>
        <div class="near-water-layer"></div>
        <div class="caustic-overlay"></div>
    </div>

    <!-- Game Container -->
    <div id="gameContainer" class="game-container">


        <!-- Header UI -->
        <div class="header">
            <div class="team-info team-left">
                <div class="player-name" id="leftPlayerName">Left Team</div>
                <div class="player-score" id="leftPlayerScore">Score: 0</div>
            </div>
            
            <div class="timer-container">
                <div class="timer" id="gameTimer">2:00</div>
                <button class="stop-button" id="stopButton" onclick="toggleGamePause()">⏸️ STOP</button>
            </div>
            
            <div class="team-info team-right">
                <div class="player-name" id="rightPlayerName">Right Team</div>
                <div class="player-score" id="rightPlayerScore">Score: 0</div>
            </div>
        </div>

        <!-- Ocean Container -->
        <div class="ocean-container">
            <!-- Left Ocean Panel -->
            <div class="ocean-panel" id="leftOcean">
                <div class="bubble-container" id="leftBubbles"></div>
                <div class="bins-container">
                    <div class="bin recycling-bin" data-type="recycling" data-team="left">
                        <div class="bin-icon">♻️</div>
                        <div class="bin-label">Recycling</div>
                    </div>
                    <div class="bin garbage-bin" data-type="garbage" data-team="left">
                        <div class="bin-icon">🗑️</div>
                        <div class="bin-label">Garbage</div>
                    </div>
                </div>
            </div>

            <!-- Central Divider -->
            <div class="divider"></div>

            <!-- Right Ocean Panel -->
            <div class="ocean-panel" id="rightOcean">
                <div class="bubble-container" id="rightBubbles"></div>
                <div class="bins-container">
                    <div class="bin recycling-bin" data-type="recycling" data-team="right">
                        <div class="bin-icon">♻️</div>
                        <div class="bin-label">Recycling</div>
                    </div>
                    <div class="bin garbage-bin" data-type="garbage" data-team="right">
                        <div class="bin-icon">🗑️</div>
                        <div class="bin-label">Garbage</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Countdown Display -->
    <div id="countdown" class="countdown">3</div>

    <!-- Results Modal -->
    <div id="resultsModal" class="modal results-modal">
        <div class="modal-content">
            <h2>本轮结束 / Round Complete!</h2>
            <div id="roundResults"></div>
            <div class="leaderboard">
                <h3>排行榜 / Leaderboard</h3>
                <div id="leaderboardList"></div>
            </div>

        </div>
    </div>

    <script>
        // Game State
        let gameState = {
            selectedGrade: null,
            audioEnabled: false,
            allPlayers: [],
            remainingPlayers: [],
            currentPlayers: { left: null, right: null },
            scores: { left: 0, right: 0 },
            playerScores: { left: 0, right: 0 },
            combos: { left: 0, right: 0 },
            lastDropTime: { left: 0, right: 0 },
            leaderboard: JSON.parse(localStorage.getItem('oceanCleanupLeaderboard') || '[]'),
            gameActive: false,
            gamePaused: false,
            timeRemaining: 120,
            gameObjects: [],
            targetObjectCount: 20,
            currentSpeed: 0.1,
            mousePosition: { x: 0, y: 0 },
            currentBurst: null,
            magnetismRange: 80,
            performanceMode: false,
            lastFrameTime: 0,
            frameCount: 0,
            fps: 60,
            roundNumber: 1,
            totalRounds: 0,
            gameTimer: null
        };

        // Performance monitoring
        function monitorPerformance() {
            const now = performance.now();
            gameState.frameCount++;
            
            if (now - gameState.lastFrameTime >= 1000) {
                gameState.fps = gameState.frameCount;
                gameState.frameCount = 0;
                gameState.lastFrameTime = now;
                
                // Enable performance mode if FPS drops below 45
                if (gameState.fps < 45 && !gameState.performanceMode) {
                    enablePerformanceMode();
                } else if (gameState.fps > 55 && gameState.performanceMode) {
                    disablePerformanceMode();
                }
            }
            
            if (gameState.gameActive) {
                requestAnimationFrame(monitorPerformance);
            }
        }

        function enablePerformanceMode() {
            gameState.performanceMode = true;
            gameState.targetObjectCount = Math.max(15, gameState.targetObjectCount - 5);
            
            // Reduce particle effects
            document.querySelectorAll('.bubble').forEach(bubble => {
                if (Math.random() < 0.5) {
                    bubble.style.display = 'none';
                }
            });
            
            console.log('Performance mode enabled - reduced object count to', gameState.targetObjectCount);
        }

        function disablePerformanceMode() {
            gameState.performanceMode = false;
            gameState.targetObjectCount = Math.min(25, gameState.targetObjectCount + 5);
            
            // Restore particle effects
            document.querySelectorAll('.bubble').forEach(bubble => {
                bubble.style.display = 'block';
            });
            
            console.log('Performance mode disabled - restored object count to', gameState.targetObjectCount);
        }

        // Audio Context
        let audioContext;
        let speechSynthesis = window.speechSynthesis;

        // Game Objects Data
        const gameObjectsData = {
            plastics: [
                { emoji: '🧴', name: 'Plastic Bottle' },
                { emoji: '🥤', name: 'Plastic Cup' },
                { emoji: '🛍️', name: 'Plastic Bag' },
                { emoji: '🍴', name: 'Plastic Utensils' },
                { emoji: '🧃', name: 'Juice Box' },
                { emoji: '🍾', name: 'Plastic Bottle' },
                { emoji: '🍼', name: 'Baby Bottle' },
                { emoji: '🪥', name: 'Toothbrush' },
                { emoji: '💳', name: 'Credit Card' },
                { emoji: '🧩', name: 'Puzzle Piece' },
                { emoji: '🧸', name: 'Toy Bear' },
                { emoji: '🪣', name: 'Bucket' },
                { emoji: '🧼', name: 'Soap' },
                { emoji: '🧽', name: 'Sponge' },
                { emoji: '🧊', name: 'Ice Cube Tray' }
            ],
            trash: [
                { emoji: '🗑️', name: 'Trash Can' },
                { emoji: '🚮', name: 'Litter Bin' },
                { emoji: '🍌', name: 'Banana Peel' },
                { emoji: '🥡', name: 'Takeout Box' },
                { emoji: '🍕', name: 'Pizza Slice' },
                { emoji: '🦴', name: 'Bone' },
                { emoji: '🍗', name: 'Chicken Leg' },
                { emoji: '🥩', name: 'Meat' },
                { emoji: '🧁', name: 'Cupcake' },
                { emoji: '🍰', name: 'Cake' },
                { emoji: '🥟', name: 'Dumpling' },
                { emoji: '🍟', name: 'French Fries' },
                { emoji: '🍔', name: 'Burger' },
                { emoji: '🥪', name: 'Sandwich' },
                { emoji: '🍳', name: 'Fried Egg' },
                { emoji: '🥫', name: 'Canned Food' },
                { emoji: '🧻', name: 'Toilet Paper' },
                { emoji: '🪳', name: 'Cockroach' },
                { emoji: '🪰', name: 'Fly' },
                { emoji: '🧹', name: 'Broom' }
            ],
            seaLife: [
                { emoji: '🐟', name: 'Fish' },
                { emoji: '🐠', name: 'Tropical Fish' },
                { emoji: '🐡', name: 'Pufferfish' },
                { emoji: '🦈', name: 'Shark' },
                { emoji: '🐬', name: 'Dolphin' },
                { emoji: '🐳', name: 'Whale' },
                { emoji: '🐋', name: 'Blue Whale' },
                { emoji: '🐙', name: 'Octopus' },
                { emoji: '🦑', name: 'Squid' },
                { emoji: '🦐', name: 'Shrimp' },
                { emoji: '🦞', name: 'Lobster' },
                { emoji: '🦀', name: 'Crab' },
                { emoji: '🐚', name: 'Shell' },
                { emoji: '🪸', name: 'Coral' },
                { emoji: '🪼', name: 'Jellyfish' },
                { emoji: '🐢', name: 'Sea Turtle' },
                { emoji: '🐊', name: 'Crocodile' },
                { emoji: '🐌', name: 'Snail' },
                { emoji: '🐦‍⬛', name: 'Sea Bird' },
                { emoji: '🐉', name: 'Sea Dragon' },
                { emoji: '🧜‍♀️', name: 'Mermaid' },
                { emoji: '🧜‍♂️', name: 'Merman' },
                { emoji: '🧜', name: 'Merperson' }
            ]
        };

        // Initialize
        function init() {
            // Track mouse and touch position for sea life avoidance
            document.addEventListener('mousemove', (e) => {
                gameState.mousePosition.x = e.clientX;
                gameState.mousePosition.y = e.clientY;
                updateSeaLifeAvoidance();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length > 0) {
                    gameState.mousePosition.x = e.touches[0].clientX;
                    gameState.mousePosition.y = e.touches[0].clientY;
                    updateSeaLifeAvoidance();
                }
            }, { passive: true });

            // Handle resize and orientation changes
            window.addEventListener('resize', handleResize);
            window.addEventListener('orientationchange', () => {
                setTimeout(handleResize, 100); // Delay for orientation change
            });

        // Toggle game pause function
        window.toggleGamePause = function() {
            const stopButton = document.getElementById('stopButton');
            
            if (gameState.gamePaused) {
                // Resume game
                gameState.gamePaused = false;
                stopButton.textContent = '⏸️ STOP';
                stopButton.classList.remove('stopped');
                
                // Resume all animations
                document.querySelectorAll('.game-object').forEach(obj => {
                    obj.style.animationPlayState = 'running';
                    if (obj.physics) {
                        obj.physics.paused = false;
                    }
                });
                
                // Resume timer
                if (gameState.gameActive) {
                    startGameTimer();
                }
                
            } else {
                // Pause game
                gameState.gamePaused = true;
                stopButton.textContent = '▶️ START';
                stopButton.classList.add('stopped');
                
                // Pause all animations
                document.querySelectorAll('.game-object').forEach(obj => {
                    obj.style.animationPlayState = 'paused';
                    if (obj.physics) {
                        obj.physics.paused = true;
                    }
                });
                
                // Pause timer
                if (gameState.gameTimer) {
                    clearInterval(gameState.gameTimer);
                    gameState.gameTimer = null;
                }
            }
        }

            // Start bubble generation
            startBubbleGeneration();
        }

        function handleResize() {
            if (!gameState.gameActive) return;
            
            // Recompute all game object positions relative to new viewport
            document.querySelectorAll('.game-object').forEach(obj => {
                const panel = obj.parentNode;
                if (!panel) return;
                
                const panelRect = panel.getBoundingClientRect();
                const currentX = parseFloat(obj.style.left) || 0;
                const currentY = parseFloat(obj.style.top) || 0;
                
                // Keep objects within bounds after resize
                const maxX = panelRect.width - 50;
                const maxY = panelRect.height - 50;
                
                obj.style.left = Math.min(currentX, maxX) + 'px';
                obj.style.top = Math.min(Math.max(currentY, 100), maxY) + 'px';
            });
            
            // Update bin hit detection zones (they auto-adjust with CSS)
            // Update magnetism ranges based on new viewport
            updateMagnetismRanges();
        }

        function updateMagnetismRanges() {
            // Adjust magnetism range based on screen size
            const screenWidth = window.innerWidth;
            const baseRange = screenWidth < 768 ? 60 : 80; // Smaller range on mobile
            
            // Store updated range for use in drag detection
            gameState.magnetismRange = baseRange;
        }

        // Bubble Generation System
        function startBubbleGeneration() {
            setInterval(() => {
                if (Math.random() < 0.7) {
                    createBubble('leftBubbles');
                }
                if (Math.random() < 0.7) {
                    createBubble('rightBubbles');
                }
            }, 2000);
        }

        function createBubble(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            
            const size = Math.random() * 20 + 10; // 10-30px
            bubble.style.width = size + 'px';
            bubble.style.height = size + 'px';
            bubble.style.left = Math.random() * 90 + '%';
            bubble.style.animationDuration = (Math.random() * 4 + 6) + 's'; // 6-10s
            bubble.style.animationDelay = Math.random() * 2 + 's';

            container.appendChild(bubble);

            // Remove bubble after animation
            setTimeout(() => {
                if (bubble.parentNode) {
                    bubble.parentNode.removeChild(bubble);
                }
            }, 12000);
        }

        // Grade Selection
        function selectGrade(grade) {
            gameState.selectedGrade = grade;
            
            // Load grade-specific roster
            if (studentRoster[grade]) {
                gameState.allPlayers = [...studentRoster[grade]];
                gameState.remainingPlayers = [...studentRoster[grade]];
                gameState.totalRounds = Math.floor(gameState.allPlayers.length / 2);
                gameState.roundNumber = 1;
            }
            
            document.getElementById('gradeModal').style.display = 'none';
            
            // Auto-enable audio and start game
            gameState.audioEnabled = true;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Start first round immediately
            selectNextPlayers();
        }

        // Student Roster Data
        const studentRoster = {
            10: [
                '冯奕尘 / FENG, YICHEN',
                '黄若涵 / HUANG, RUOHAN',
                '李丰屹 / LI, FENGYI',
                '李鹏潞 / LI, PENGLU',
                '梁锦天 / LING, JINTIAN',
                '刘景扬 / LIU, JINGYANG',
                '龙俊志 / LONG, JUNZHI',
                '马赫 / MA, HE',
                '聂溪康 / NIE, XIKANG',
                '庞云蔚 / PANG, YUNWEI',
                '曲家瑞 / QU, JIARUI',
                '孙诗童 / SUN, SHITONG',
                '王子言 / WANG, ZIYAN',
                '杨晴珺 / YANG, QINGJUN',
                '张宸恺 / ZHANG, CHENKAI',
                '赵浩文 / ZHAO, HAOWEN',
                '徐浚洹 / JUN, HUANXU'
            ],
            11: [
                '陈峻弘 / CHEN, JUNHONG',
                '韩睿雄 / HAN, RUIXIONG',
                '何怡敏 / HE, YIMIN',
                '康艺芸 / KANG, YIYUN',
                '李雨霏 / LI, YUFEI',
                '李沾衣 / LI, ZHANYI',
                '刘圃言 / LIU, PUYAN',
                '庞泽霖 / PANG, ZELIN',
                '王梓晗 / WANG, ZIHAN',
                '尹九思 / YIN, JIUSI',
                '游项雯 / YOU, XIANGWEN',
                '于浚哲 / YU, JUNZHE',
                '臧姝婷 / ZANG, SHUTING',
                '张澜馨 / ZHANG, LANXIN'
            ],
            12: [
                '安政聿 / AN, ZHENGYU',
                '蔡子墨 / CAI, ZIMO',
                '刘镇榕 / LIU, ZHENRONG',
                '马知行 / MA, ZHIXING',
                '邱天 / QIU, TIAN',
                '盛思语 / SHENG, SIYU',
                '唐可盈 / TANG, KEYING',
                '田子凡 / TIAN, ZIFAN',
                '谢斯飞 / XIE, SIFEI',
                '杨加麒 / YANG, JIAQI',
                '张程皓 / ZHANG, CHENGHAO',
                '赵晨达鑫 / ZHAO, CHENDAXIN',
                '周逸凡 / ZHOU, YIFAN'
            ]
        };

        // Player Selection System
        function selectNextPlayers() {
            if (gameState.remainingPlayers.length < 2) {
                // Tournament complete
                showFinalResults();
                return;
            }

            // Show name shuffling animation first
            showNameShuffling();
        }

        function showNameShuffling() {
            document.getElementById('nameShuffleContainer').style.display = 'flex';
            
            const leftNameEl = document.getElementById('shuffleNameLeft');
            const rightNameEl = document.getElementById('shuffleNameRight');
            const progressBar = document.getElementById('shuffleBar');
            const timerEl = document.getElementById('shuffleTimer');
            
            let timeRemaining = 5;
            let shuffleCount = 0;
            const maxShuffles = 50; // 5 seconds * 10 updates per second
            let selectedLeft = null;
            let selectedRight = null;
            
            // Pre-select the players at the start
            for (let i = gameState.remainingPlayers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.remainingPlayers[i], gameState.remainingPlayers[j]] = [gameState.remainingPlayers[j], gameState.remainingPlayers[i]];
            }
            
            selectedLeft = gameState.remainingPlayers[0];
            selectedRight = gameState.remainingPlayers[1];
            
            // Play shuffle start sound
            playShuffleSound('start');
            
            // Timer countdown
            const timerInterval = setInterval(() => {
                timeRemaining--;
                timerEl.textContent = timeRemaining;
                
                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                }
                
                // Play tick sound for last 3 seconds
                if (timeRemaining <= 3 && timeRemaining > 0) {
                    playShuffleSound('tick');
                }
            }, 1000);
            
            const shuffleInterval = setInterval(() => {
                shuffleCount++;
                
                // Update progress bar smoothly
                const progress = (shuffleCount / maxShuffles) * 100;
                progressBar.style.width = progress + '%';
                
                // Smooth shuffling phase - gradually slow down
                if (shuffleCount < maxShuffles - 5) {
                    // Create smooth transition by occasionally showing the final names
                    const showFinalChance = shuffleCount / maxShuffles;
                    
                    if (Math.random() < showFinalChance) {
                        // Show final names more frequently as we progress
                        leftNameEl.textContent = selectedLeft.split(' / ')[0];
                        rightNameEl.textContent = selectedRight.split(' / ')[0];
                    } else {
                        // Show random names less frequently as we progress
                        const randomLeft = gameState.remainingPlayers[Math.floor(Math.random() * gameState.remainingPlayers.length)];
                        const randomRight = gameState.remainingPlayers[Math.floor(Math.random() * gameState.remainingPlayers.length)];
                        
                        leftNameEl.textContent = randomLeft.split(' / ')[0];
                        rightNameEl.textContent = randomRight.split(' / ')[0];
                    }
                    
                } else if (shuffleCount === maxShuffles - 5) {
                    // Final selection phase - lock in the names
                    leftNameEl.textContent = selectedLeft.split(' / ')[0];
                    rightNameEl.textContent = selectedRight.split(' / ')[0];
                    leftNameEl.classList.add('selected');
                    rightNameEl.classList.add('selected');
                    
                    // Play selection sound
                    playShuffleSound('select');
                    
                } else if (shuffleCount >= maxShuffles) {
                    // Shuffling complete
                    clearInterval(shuffleInterval);
                    clearInterval(timerInterval);
                    
                    // Set the selected players
                    gameState.currentPlayers.left = selectedLeft;
                    gameState.currentPlayers.right = selectedRight;
                    
                    // Remove selected players from remaining pool
                    gameState.remainingPlayers = gameState.remainingPlayers.slice(2);
                    
                    // Play completion sound
                    playShuffleSound('complete');
                    
                    // Announce in Chinese
                    if (gameState.audioEnabled) {
                        setTimeout(() => {
                            speakChinese(`第${gameState.roundNumber}轮选手确定`);
                        }, 500);
                    }
                    
                    // Transition to next players screen after a pause
                    setTimeout(() => {
                        document.getElementById('nameShuffleContainer').style.display = 'none';
                        showNextPlayersScreen();
                    }, 2000);
                }
            }, 100); // 10 updates per second for 5 seconds
        }

        function playShuffleSound(type) {
            if (!gameState.audioEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch (type) {
                case 'start':
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'tick':
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.03, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;
                case 'select':
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1000, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                case 'complete':
                    oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.8);
                    break;
            }
        }

        function showNextPlayersScreen() {
            document.getElementById('nextPlayerLeft').textContent = gameState.currentPlayers.left;
            document.getElementById('nextPlayerRight').textContent = gameState.currentPlayers.right;
            document.getElementById('nextPlayersContainer').style.display = 'flex';

            // Announce in Chinese
            if (gameState.audioEnabled) {
                setTimeout(() => {
                    speakChinese(`第${gameState.roundNumber}轮，左队：${gameState.currentPlayers.left.split(' / ')[0]}`);
                    setTimeout(() => {
                        speakChinese(`右队：${gameState.currentPlayers.right.split(' / ')[0]}`);
                    }, 2000);
                }, 500);
            }

            // 10 second countdown
            let countdown = 10;
            const countdownEl = document.getElementById('nextCountdown');
            
            const countInterval = setInterval(() => {
                countdown--;
                countdownEl.textContent = countdown;
                
                if (countdown <= 0) {
                    clearInterval(countInterval);
                    document.getElementById('nextPlayersContainer').style.display = 'none';
                    startGame();
                }
            }, 1000);
        }

        function speakChinese(text) {
            if (!gameState.audioEnabled) return;
            
            try {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'zh-CN';
                utterance.rate = 0.7;
                
                // Prioritize Microsoft XiaoxiaoNeural voice
                const voices = speechSynthesis.getVoices();
                const chineseVoice = voices.find(voice => 
                    voice.name === 'Microsoft XiaoxiaoNeural - Chinese (Mainland)' ||
                    voice.name.includes('zh-CN-XiaoxiaoNeural') ||
                    voice.name.includes('XiaoxiaoNeural') ||
                    voice.name.includes('zh‑CN-XiaoxiaoNeural') ||
                    voice.name.includes('XiaoXiao') ||
                    voice.name.includes('zh-CN-XiaoxiaoMultilingualNeural') ||
                    voice.name.includes('YunXi') || 
                    voice.name.includes('Yunxi') ||
                    voice.name.includes('zh-CN-YunxiNeural') ||
                    voice.name.includes('zh-CN-YunyangNeural') ||
                    voice.name.includes('zh-CN-YunyeNeural') ||
                    voice.name.includes('zh-CN-YunhaoNeural') ||
                    voice.name.includes('zh-CN-YunjianNeural') ||
                    (voice.lang.includes('zh') && voice.name.includes('Neural')) ||
                    voice.lang.includes('zh-CN') || 
                    voice.name.includes('Chinese')
                );
                
                if (chineseVoice) {
                    utterance.voice = chineseVoice;
                    console.log('Using Chinese voice:', chineseVoice.name);
                } else {
                    console.log('XiaoxiaoNeural not found, available voices:', voices.filter(v => v.lang.includes('zh')).map(v => v.name));
                }
                
                // Error handling for Chinese TTS
                utterance.onerror = (event) => {
                    console.warn('Chinese TTS Error:', event.error);
                    showTTSWarning();
                    showCaptionFallback(text);
                };
                
                utterance.onend = () => {
                    hideTTSWarning();
                };
                
                speechSynthesis.speak(utterance);
                
            } catch (error) {
                console.warn('Chinese TTS not available:', error);
                showTTSWarning();
                showCaptionFallback(text);
            }
        }

        // Game Start
        function startGame() {
            document.getElementById('gameContainer').style.display = 'block';
            
            // Update player names
            document.getElementById('leftPlayerName').textContent = gameState.currentPlayers.left.split(' / ')[1] || gameState.currentPlayers.left;
            document.getElementById('rightPlayerName').textContent = gameState.currentPlayers.right.split(' / ')[1] || gameState.currentPlayers.right;
            
            // Reset scores
            gameState.scores.left = 0;
            gameState.scores.right = 0;
            gameState.playerScores.left = 0;
            gameState.playerScores.right = 0;
            gameState.combos.left = 0;
            gameState.combos.right = 0;
            updateScoreDisplay();
            
            // Start countdown
            startCountdown();
        }

        function startCountdown() {
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            
            let count = 3;
            countdownEl.textContent = count;
            
            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.textContent = count;
                    playSound('beep');
                } else {
                    countdownEl.textContent = '开始! / GO!';
                    playSound('start');
                    setTimeout(() => {
                        countdownEl.style.display = 'none';
                        beginGameplay();
                    }, 1000);
                    clearInterval(countInterval);
                }
            }, 1000);
        }

        // Gameplay
        function beginGameplay() {
            gameState.gameActive = true;
            gameState.timeRemaining = 120;
            gameState.currentSpeed = 0.1;
            
            // Initialize magnetism range based on screen size
            updateMagnetismRanges();
            
            // Start performance monitoring
            monitorPerformance();
            
            // Start timer
            startGameTimer();
            
            // Start ocean ambience
            playOceanAmbience();
            
            // Announce team readiness
            if (gameState.audioEnabled) {
                setTimeout(() => {
                    speakWithFallback("Left team ready!", 'Ava');
                    setTimeout(() => {
                        speakWithFallback("Right team ready!", 'Andrew');
                    }, 1000);
                }, 500);
            }
            
            // Start object management
            startObjectManagement();
            
            // Start current bursts
            startCurrentBursts();
        }

        function startGameTimer() {
            if (gameState.gameTimer) {
                clearInterval(gameState.gameTimer);
            }
            
            gameState.gameTimer = setInterval(() => {
                if (gameState.gamePaused) return; // Don't count down when paused
                
                gameState.timeRemaining--;
                updateTimerDisplay();
                
                // Timer warnings and speed changes
                if (gameState.timeRemaining === 30) {
                    playSound('tick');
                    gameState.currentSpeed = 1.5;
                    document.getElementById('gameTimer').classList.add('warning');
                } else if (gameState.timeRemaining === 10) {
                    document.getElementById('gameTimer').classList.remove('warning');
                    document.getElementById('gameTimer').classList.add('critical');
                    gameState.currentSpeed = 2;
                }
                
                if (gameState.timeRemaining <= 0) {
                    clearInterval(gameState.gameTimer);
                    gameState.gameTimer = null;
                    playSound('horn');
                    endGame();
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(gameState.timeRemaining / 60);
            const seconds = gameState.timeRemaining % 60;
            document.getElementById('gameTimer').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function startObjectManagement() {
            // Initial spawn - just start the maintenance
            maintainObjectDensity();
            
            // Regular maintenance - slower interval
            setInterval(() => {
                if (gameState.gameActive) {
                    maintainObjectDensity();
                    cleanupOffscreenObjects();
                }
            }, 2000); // Increased from 800ms to 2000ms
            
            // Add 10 more emojis every 10 seconds
            setInterval(() => {
                if (gameState.gameActive && !gameState.gamePaused) {
                    // Add 5 emojis to each panel
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => spawnInPanel('leftOcean', 'left'), i * 150);
                        setTimeout(() => spawnInPanel('rightOcean', 'right'), i * 150);
                    }
                }
            }, 10000); // Every 10 seconds
        }

        function maintainObjectDensity() {
            if (gameState.gamePaused) return; // Don't spawn when paused
            
            const leftObjects = document.querySelectorAll('#leftOcean .game-object').length;
            const rightObjects = document.querySelectorAll('#rightOcean .game-object').length;
            
            const targetPerPanel = 25; // Increased for more emojis
            
            // Spawn more objects at once
            if (leftObjects < targetPerPanel) {
                const toSpawn = Math.min(3, targetPerPanel - leftObjects); // Max 3 at once
                for (let i = 0; i < toSpawn; i++) {
                    setTimeout(() => spawnInPanel('leftOcean', 'left'), i * 300); // Slower stagger spawning
                }
            }
            
            if (rightObjects < targetPerPanel) {
                const toSpawn = Math.min(3, targetPerPanel - rightObjects); // Max 3 at once
                for (let i = 0; i < toSpawn; i++) {
                    setTimeout(() => spawnInPanel('rightOcean', 'right'), i * 300); // Slower stagger spawning
                }
            }
        }

        function cleanupOffscreenObjects() {
            document.querySelectorAll('.game-object').forEach(obj => {
                const rect = obj.getBoundingClientRect();
                const parentRect = obj.parentNode.getBoundingClientRect();
                
                // Remove if completely off-screen for too long
                if (rect.right < parentRect.left - 100 || 
                    rect.left > parentRect.right + 100 ||
                    rect.bottom < parentRect.top - 100 ||
                    rect.top > parentRect.bottom + 100) {
                    
                    if (!obj.dataset.offscreenTime) {
                        obj.dataset.offscreenTime = Date.now();
                    } else if (Date.now() - parseInt(obj.dataset.offscreenTime) > 5000) {
                        obj.parentNode.removeChild(obj);
                    }
                } else {
                    delete obj.dataset.offscreenTime;
                }
            });
        }

        function spawnInPanel(panelId, team) {
            const panel = document.getElementById(panelId);
            const panelRect = panel.getBoundingClientRect();
            
            // Weighted random based on grade difficulty - more sea creatures!
            const gradeWeights = {
                10: { plastic: 0.25, trash: 0.15, sealife: 0.6 },
                11: { plastic: 0.3, trash: 0.2, sealife: 0.5 },
                12: { plastic: 0.35, trash: 0.25, sealife: 0.4 }
            };
            
            const weights = gradeWeights[gameState.selectedGrade] || gradeWeights[10];
            const rand = Math.random();
            let objectData, type;
            
            if (rand < weights.plastic) {
                objectData = gameObjectsData.plastics[Math.floor(Math.random() * gameObjectsData.plastics.length)];
                type = 'plastic';
            } else if (rand < weights.plastic + weights.trash) {
                objectData = gameObjectsData.trash[Math.floor(Math.random() * gameObjectsData.trash.length)];
                type = 'trash';
            } else {
                objectData = gameObjectsData.seaLife[Math.floor(Math.random() * gameObjectsData.seaLife.length)];
                type = 'sealife';
            }
            
            const object = document.createElement('div');
            object.className = `game-object ${type === 'plastic' ? 'plastic-item' : type === 'trash' ? 'trash-item' : 'sea-creature'}`;
            object.textContent = objectData.emoji; // Use textContent instead of innerHTML for emojis
            object.dataset.type = type;
            object.dataset.team = team;
            object.title = objectData.name;
            
            // Always spawn from top for natural falling motion
            let startX, startY;
            
            // Spawn from top with some horizontal variation
            startX = Math.random() * (panelRect.width - 100) + 50; // Keep away from edges
            startY = -50; // Start above the visible area
            
            object.style.left = startX + 'px';
            object.style.top = startY + 'px';
            
            // Add natural fall-and-float behavior
            object.classList.add('natural-fall');
            
            // Add slight rotation for items (not sea creatures)
            if (type !== 'sealife' && Math.random() < 0.4) {
                object.classList.add('gentle-rotate');
            }
            
            // Set random drift and animation duration
            const driftX = (Math.random() - 0.5) * 100; // -50px to +50px horizontal drift
            object.style.setProperty('--drift-x', driftX + 'px');
            
            // Much slower animation duration for variety
            const duration = 100 + Math.random() * 80; // 100-180 seconds (even slower)
            
            if (gameState.gamePaused) {
                object.style.animationPlayState = 'paused';
            } else {
                object.style.animationDuration = `${duration}s`;
            }
            
            panel.appendChild(object);
            
            // Add physics properties - ultra slow default
            object.physics = {
                vx: gameState.gamePaused ? 0 : (Math.random() - 0.5) * 0.00001,
                vy: gameState.gamePaused ? 0 : (Math.random() - 0.5) * 0.00001,
                mass: type === 'sealife' ? 0.5 : 1,
                paused: gameState.gamePaused,
                maxY: window.innerHeight - 350 // Keep above bins
            };
            
            // Set animation state based on pause
            if (gameState.gamePaused) {
                object.style.animationPlayState = 'paused';
            } else {
                object.style.animationDuration = `${duration}s`;
            }
            
            // Add drag functionality
            if (type !== 'sealife') {
                makeDraggable(object);
            } else {
                object.addEventListener('mousedown', handleSeaLifeClick);
            }
            
            // Start physics simulation
            startObjectPhysics(object);
        }

        function spawnSeaCreature(panelId, team) {
            const panel = document.getElementById(panelId);
            const panelRect = panel.getBoundingClientRect();
            
            // Always spawn sea creatures
            const objectData = gameObjectsData.seaLife[Math.floor(Math.random() * gameObjectsData.seaLife.length)];
            const type = 'sealife';
            
            const object = document.createElement('div');
            object.className = 'game-object sea-creature';
            object.innerHTML = objectData.emoji;
            object.dataset.type = type;
            object.dataset.team = team;
            object.title = objectData.name;
            
            // Spawn from random edges
            const spawnSide = Math.floor(Math.random() * 4);
            let startX, startY;
            
            switch (spawnSide) {
                case 0: // Top
                    startX = Math.random() * panelRect.width;
                    startY = -50;
                    break;
                case 1: // Right
                    startX = panelRect.width + 50;
                    startY = Math.random() * panelRect.height;
                    break;
                case 2: // Bottom
                    startX = Math.random() * panelRect.width;
                    startY = panelRect.height + 50;
                    break;
                case 3: // Left
                    startX = -50;
                    startY = Math.random() * panelRect.height;
                    break;
            }
            
            object.style.left = startX + 'px';
            object.style.top = startY + 'px';
            
            // Add schooling behavior
            if (Math.random() < 0.7) {
                object.classList.add('schooling');
            } else {
                const patterns = ['sine-wave', 'floating', 'drifting'];
                const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                object.classList.add(pattern);
            }
            
            // Set random drift and animation duration
            const driftX = (Math.random() - 0.5) * 100; // -50px to +50px horizontal drift
            object.style.setProperty('--drift-x', driftX + 'px');
            
            // Much slower animation duration for variety
            const duration = 80 + Math.random() * 60; // 80-140 seconds (much slower)
            
            if (gameState.gamePaused) {
                object.style.animationPlayState = 'paused';
            } else {
                object.style.animationDuration = `${duration}s`;
            }
            
            panel.appendChild(object);
            
            // Add physics properties - ultra slow default
            object.physics = {
                vx: gameState.currentSpeed === 0 ? 0 : (Math.random() - 0.5) * 0.00002 * speed,
                vy: gameState.currentSpeed === 0 ? 0 : (Math.random() - 0.5) * 0.00002 * speed,
                mass: 0.5,
                paused: gameState.currentSpeed === 0
            };
            
            // Add click and touch handlers
            object.addEventListener('mousedown', handleSeaLifeClick);
            object.addEventListener('touchstart', handleSeaLifeClick, { passive: false });
            
            // Start physics simulation
            startObjectPhysics(object);
        }

        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('touchstart', startDrag, { passive: false });
            
            function startDrag(e) {
                if (!gameState.gameActive) return;
                
                isDragging = true;
                element.classList.add('dragging');
                playSound('pickup');
                
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                startX = clientX;
                startY = clientY;
                initialX = element.offsetLeft;
                initialY = element.offsetTop;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag, { passive: false });
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchend', stopDrag);
                
                e.preventDefault();
            }
            
            function drag(e) {
                if (!isDragging) return;
                
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                const deltaX = clientX - startX;
                const deltaY = clientY - startY;
                
                element.style.left = initialX + deltaX + 'px';
                element.style.top = initialY + deltaY + 'px';
                
                // Check bin hover
                checkBinHover(element, clientX, clientY);
            }
            
            function stopDrag(e) {
                if (!isDragging) return;
                
                isDragging = false;
                element.classList.remove('dragging');
                playSound('drop');
                
                // Check drop
                const clientX = e.clientX || e.changedTouches[0].clientX;
                const clientY = e.clientY || e.changedTouches[0].clientY;
                
                checkDrop(element, clientX, clientY);
                
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchend', stopDrag);
                
                // Clear bin hovers
                document.querySelectorAll('.bin').forEach(bin => {
                    bin.classList.remove('hover-glow');
                });
            }
        }

        function checkBinHover(element, x, y) {
            const team = element.dataset.team;
            const bins = document.querySelectorAll(`.bin[data-team="${team}"]`);
            
            bins.forEach(bin => {
                const rect = bin.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                
                const isHovering = x >= rect.left && x <= rect.right && 
                                 y >= rect.top && y <= rect.bottom;
                const isNearby = distance < 120; // Magnetism range
                
                if (isHovering || isNearby) {
                    const binType = bin.dataset.type;
                    const objectType = element.dataset.type;
                    
                    if ((binType === 'recycling' && objectType === 'plastic') ||
                        (binType === 'garbage' && objectType === 'trash')) {
                        
                        bin.classList.add('correct-hover');
                        element.classList.add('correct-outline');
                        
                        // Magnetism effect when very close
                        const magnetRange = gameState.magnetismRange || 80;
                        if (distance < magnetRange) {
                            bin.classList.add('magnetism');
                            element.classList.add('magnetic-pull');
                            
                            // Apply magnetic pull to element position
                            const pullStrength = Math.max(0, (magnetRange - distance) / magnetRange) * 10;
                            const pullX = (centerX - x) * pullStrength * 0.1;
                            const pullY = (centerY - y) * pullStrength * 0.1;
                            
                            element.style.transform = `translate(${pullX}px, ${pullY}px) scale(1.2)`;
                        }
                    } else {
                        bin.classList.add('hover-glow');
                    }
                } else {
                    bin.classList.remove('hover-glow', 'correct-hover', 'magnetism');
                    element.classList.remove('correct-outline', 'magnetic-pull');
                    if (element.classList.contains('dragging')) {
                        element.style.transform = 'scale(1.2)';
                    }
                }
            });
        }

        function checkDrop(element, x, y) {
            const team = element.dataset.team;
            const bins = document.querySelectorAll(`.bin[data-team="${team}"]`);
            
            // Check cooldown and prevent duplicate scoring
            const now = Date.now();
            if (now - gameState.lastDropTime[team] < 300 || element.dataset.scored === 'true') {
                return; // Anti-spam cooldown and duplicate prevention
            }
            
            let dropped = false;
            let nearestBin = null;
            let minDistance = Infinity;
            
            // Find nearest bin for better drop detection
            bins.forEach(bin => {
                const rect = bin.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestBin = bin;
                }
            });
            
            // Check if dropped in any bin with improved hit detection
            bins.forEach(bin => {
                const rect = bin.getBoundingClientRect();
                const isDropped = x >= rect.left - 25 && x <= rect.right + 25 && 
                                  y >= rect.top - 25 && y <= rect.bottom + 25;
                
                if (isDropped) {
                    const binType = bin.dataset.type;
                    const objectType = element.dataset.type;
                    
                    // Mark as scored to prevent duplicates
                    element.dataset.scored = 'true';
                    gameState.lastDropTime[team] = now;
                    
                    if ((binType === 'recycling' && objectType === 'plastic') ||
                        (binType === 'garbage' && objectType === 'trash')) {
                        // Correct drop
                        gameState.playerScores[team] += 1;
                        gameState.scores[team] += 1;
                        gameState.combos[team]++;
                        
                        let points = 1;
                        let feedback = '+1';
                        
                        // Combo bonus
                        if (gameState.combos[team] >= 5 && gameState.combos[team] % 5 === 0) {
                            points += 2;
                            feedback = '+3 COMBO!';
                            playSound('combo');
                        } else {
                            playSound('correct');
                        }
                        
                        showFeedback(feedback, element, 'green');
                        
                        // Create success burst effect
                        createSuccessBurst(element);
                        
                        // Create sparkles for correct drops
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => createSparkle(element), i * 100);
                        }
                        
                        // Voice feedback (rate limited)
                        if (gameState.combos[team] <= 3) {
                            const correctMessages = [
                                objectType === 'plastic' ? "Plastic to recycling!" : "Trash to garbage!",
                                "Good job!",
                                "Correct!"
                            ];
                            const message = correctMessages[Math.floor(Math.random() * correctMessages.length)];
                            setTimeout(() => speakWithFallback(message, team === 'left' ? 'Ava' : 'Andrew'), 100);
                        }
                        
                    } else {
                        // Incorrect drop
                        gameState.playerScores[team] = Math.max(0, gameState.playerScores[team] - 1);
                        gameState.scores[team] = Math.max(0, gameState.scores[team] - 1);
                        gameState.combos[team] = 0; // Reset combo
                        
                        playSound('incorrect');
                        showFeedback('-1', element, 'red');
                        
                        // Voice correction
                        const correctionMessages = [
                            objectType === 'plastic' ? "Plastic goes to recycling!" : "Try the garbage bin!",
                            "Wrong bin!",
                            "Check the bin type!"
                        ];
                        const message = correctionMessages[Math.floor(Math.random() * correctionMessages.length)];
                        setTimeout(() => speakWithFallback(message, team === 'left' ? 'Ava' : 'Andrew'), 100);
                    }
                    
                    updateScoreDisplay();
                    
                    // Destroy element after scoring
                    element.style.transition = 'all 0.3s ease';
                    element.style.transform = 'scale(0)';
                    element.style.opacity = '0';
                    setTimeout(() => {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    }, 300);
                    
                    dropped = true;
                }
            });
            
            if (!dropped) {
                // Mis-drop: Return to ocean flow with gentle animation
                returnToOceanFlow(element);
            }
        }

        function returnToOceanFlow(element) {
            if (!element.parentNode) return;
            
            // Show gentle feedback for mis-drop
            showFeedback('Return to ocean', element, 'blue');
            
            // Find a safe position in the ocean
            const panel = element.parentNode;
            const panelRect = panel.getBoundingClientRect();
            
            const safeX = Math.random() * (panelRect.width - 100) + 50;
            const safeY = Math.random() * (panelRect.height - 200) + 150;
            
            // Animate return to ocean
            element.style.transition = 'all 1s ease-out';
            element.style.left = safeX + 'px';
            element.style.top = safeY + 'px';
            element.style.transform = 'scale(1)';
            
            // Reset physics and continue simulation
            setTimeout(() => {
                element.style.transition = '';
                if (element.parentNode && element.physics) {
                    // Give it gentle random velocity
                    element.physics.vx = (Math.random() - 0.5) * 0.004;
                    element.physics.vy = (Math.random() - 0.5) * 0.004;
                    startObjectPhysics(element);
                }
            }, 1000);
        }

        function handleSeaLifeClick(e) {
            const team = e.target.dataset.team;
            const panel = document.getElementById(team + 'Ocean');
            
            // Flash red screen
            panel.classList.add('flash-red');
            setTimeout(() => {
                panel.classList.remove('flash-red');
            }, 500);
            
            // Play buzzer and voice
            playSound('buzzer');
            speak("That's an ocean creature!", team === 'left' ? 'Ava' : 'Andrew');
            
            // Show feedback
            showFeedback("That's an ocean creature!", e.target, 'orange');
            
            // Optional penalty
            gameState.playerScores[team] = Math.max(0, gameState.playerScores[team] - 1);
            gameState.scores[team] = Math.max(0, gameState.scores[team] - 1);
            gameState.combos[team] = 0; // Reset combo
            updateScoreDisplay();
            
            // Brief lockout
            e.target.style.pointerEvents = 'none';
            setTimeout(() => {
                if (e.target.parentNode) {
                    e.target.style.pointerEvents = 'auto';
                }
            }, 1000);
            
            // Avoidance animation
            e.target.classList.add('avoiding');
            setTimeout(() => {
                e.target.classList.remove('avoiding');
            }, 1000);
        }

        function showFeedback(text, element, color) {
            const feedback = document.createElement('div');
            feedback.textContent = text;
            feedback.style.cssText = `
                position: absolute;
                left: ${element.offsetLeft}px;
                top: ${element.offsetTop - 30}px;
                color: ${color};
                font-weight: bold;
                font-size: 18px;
                pointer-events: none;
                z-index: 1000;
                animation: fadeUp 1s ease-out forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeUp {
                    0% { opacity: 1; transform: translateY(0); }
                    100% { opacity: 0; transform: translateY(-30px); }
                }
            `;
            document.head.appendChild(style);
            
            element.parentNode.appendChild(feedback);
            
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.parentNode.removeChild(feedback);
                }
            }, 1000);
        }

        function createSuccessBurst(element) {
            const burst = document.createElement('div');
            burst.className = 'success-burst';
            burst.style.left = (element.offsetLeft - 15) + 'px';
            burst.style.top = (element.offsetTop - 15) + 'px';
            
            element.parentNode.appendChild(burst);
            
            setTimeout(() => {
                if (burst.parentNode) {
                    burst.parentNode.removeChild(burst);
                }
            }, 600);
        }

        function createSparkle(element) {
            if (!element.parentNode) return;
            
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            
            const offsetX = (Math.random() - 0.5) * 60;
            const offsetY = (Math.random() - 0.5) * 60;
            
            sparkle.style.left = (element.offsetLeft + 20 + offsetX) + 'px';
            sparkle.style.top = (element.offsetTop + 20 + offsetY) + 'px';
            
            element.parentNode.appendChild(sparkle);
            
            setTimeout(() => {
                if (sparkle.parentNode) {
                    sparkle.parentNode.removeChild(sparkle);
                }
            }, 1000);
        }

        function createConfetti(container, count = 20) {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'];
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.animationDelay = Math.random() * 2 + 's';
                    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                    
                    container.appendChild(confetti);
                    
                    setTimeout(() => {
                        if (confetti.parentNode) {
                            confetti.parentNode.removeChild(confetti);
                        }
                    }, 5000);
                }, i * 50);
            }
        }

        function updateScoreDisplay() {
            document.getElementById('leftPlayerScore').textContent = `Score: ${gameState.playerScores.left} | Combo: ${gameState.combos.left}`;
            document.getElementById('rightPlayerScore').textContent = `Score: ${gameState.playerScores.right} | Combo: ${gameState.combos.right}`;
        }

        // Audio Functions
        function playSound(type) {
            if (!gameState.audioEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch (type) {
                case 'beep':
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'start':
                    oscillator.frequency.setValueAtTime(1200, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                case 'correct':
                    // Pleasant chime
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'incorrect':
                    // Error beep
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                case 'buzzer':
                    // Big buzzer
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.6);
                    break;
                case 'combo':
                    // Combo sound
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                case 'tick':
                    // Subtle tick
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'horn':
                    // End horn
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 1);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 1);
                    break;
                case 'pickup':
                    // Subtle pluck
                    oscillator.frequency.setValueAtTime(500, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'drop':
                    // Subtle thunk
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
            }
        }

        function playOceanAmbience() {
            if (!gameState.audioEnabled || !audioContext) return;
            
            // Create ocean ambience with white noise
            const bufferSize = audioContext.sampleRate * 2;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * 0.1;
            }
            
            const whiteNoise = audioContext.createBufferSource();
            whiteNoise.buffer = noiseBuffer;
            whiteNoise.loop = true;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(300, audioContext.currentTime);
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.02, audioContext.currentTime);
            
            whiteNoise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            whiteNoise.start();
            
            // Stop ambience when game ends
            setTimeout(() => {
                if (!gameState.gameActive) {
                    whiteNoise.stop();
                }
            }, 120000);
        }

        // Game End
        function endGame() {
            gameState.gameActive = false;
            
            // Clear all game objects
            document.querySelectorAll('.game-object').forEach(obj => {
                obj.style.pointerEvents = 'none';
            });
            
            // Update leaderboard
            updateLeaderboard();
            
            // Show results with Chinese announcement
            showResults();
        }

        // Physics and Movement Functions
        function startObjectPhysics(object) {
            if (!object.physics) return;
            
            const updatePhysics = () => {
                if (!object.parentNode || !gameState.gameActive || gameState.gamePaused || object.physics.paused) return;
                
                const rect = object.getBoundingClientRect();
                const parentRect = object.parentNode.getBoundingClientRect();
                
                // Update position based on velocity
                let newX = parseFloat(object.style.left) + object.physics.vx;
                let newY = parseFloat(object.style.top) + object.physics.vy;
                
                // Define bin exclusion zone - keep emojis floating above bins
                const binZoneLeft = parentRect.width * 0.15;
                const binZoneRight = parentRect.width * 0.85;
                const binZoneTop = parentRect.height - 250; // Even larger exclusion zone
                
                // Check bin area collision - gentle repulsion
                if (newX > binZoneLeft && newX < binZoneRight && newY > binZoneTop) {
                    // Gentle bounce away from bin area
                    if (object.physics.vy > 0) object.physics.vy = -Math.abs(object.physics.vy) * 1; // Gentle bounce up
                    if (newX < (binZoneLeft + binZoneRight) / 2) {
                        object.physics.vx -= 0.0001; // Very gentle push left
                    } else {
                        object.physics.vx += 0.0001; // Very gentle push right
                    }
                    // Add gentle upward force to keep floating
                    object.physics.vy -= 0.001;
                }
                
                // Boundary collision
                if (newX < 0 || newX > parentRect.width - 50) {
                    object.physics.vx *= -0.9; // Bounce with damping
                }
                if (newY < 100 || newY > binZoneTop) {
                    object.physics.vy *= -0.9;
                }
                
                // Keep in bounds and floating above bins
                newX = Math.max(0, Math.min(parentRect.width - 50, newX));
                newY = Math.max(100, Math.min(binZoneTop - 50, newY)); // Keep even further above bins
                
                // Additional bin area enforcement - force floating with stronger repulsion
                if (newY > binZoneTop - 80) {
                    newY = binZoneTop - 80; // Force floating well above bins
                    object.physics.vy = -Math.abs(object.physics.vy) * 1.5; // Strong upward push
                    // Add continuous upward drift in bin area
                    object.physics.vy -= 0.005;
                }
                
                object.style.left = newX + 'px';
                object.style.top = newY + 'px';
                
                // Apply drag
                object.physics.vx *= 0.99;
                object.physics.vy *= 0.99;
                
                // Check for collisions with other objects
                handleSoftCollisions(object);
                
                // Continue physics
                requestAnimationFrame(updatePhysics);
            };
            
            requestAnimationFrame(updatePhysics);
        }

        function handleSoftCollisions(object) {
            const siblings = object.parentNode.querySelectorAll('.game-object');
            const objectRect = object.getBoundingClientRect();
            
            siblings.forEach(other => {
                if (other === object || !other.physics) return;
                
                const otherRect = other.getBoundingClientRect();
                const dx = objectRect.left - otherRect.left;
                const dy = objectRect.top - otherRect.top;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 60 && distance > 0) {
                    // Gentle separation force
                    const force = (60 - distance) * 0.01;
                    const angle = Math.atan2(dy, dx);
                    
                    object.physics.vx += Math.cos(angle) * force;
                    object.physics.vy += Math.sin(angle) * force;
                    
                    other.physics.vx -= Math.cos(angle) * force;
                    other.physics.vy -= Math.sin(angle) * force;
                }
            });
        }

        function updateSeaLifeAvoidance() {
            if (!gameState.gameActive) return;
            
            document.querySelectorAll('.sea-creature').forEach(creature => {
                const rect = creature.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const dx = gameState.mousePosition.x - centerX;
                const dy = gameState.mousePosition.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80 && distance > 0) {
                    // Much gentler avoidance - only move 8-12px away
                    const avoidX = -(dx / distance) * 8;
                    const avoidY = -(dy / distance) * 8;
                    
                    creature.style.setProperty('--avoid-x', avoidX + 'px');
                    creature.style.setProperty('--avoid-y', avoidY + 'px');
                    
                    if (!creature.classList.contains('avoiding') && !creature.classList.contains('darting')) {
                        // Chance for darting behavior when cursor gets very close
                        if (distance < 40 && Math.random() < 0.2) {
                            creature.classList.add('darting');
                            setTimeout(() => {
                                creature.classList.remove('darting');
                            }, 800);
                        } else {
                            creature.classList.add('avoiding');
                            setTimeout(() => {
                                creature.classList.remove('avoiding');
                            }, 1000);
                        }
                    }
                }
            });
        }

        function startCurrentBursts() {
            if (!gameState.gameActive) return;
            
            setInterval(() => {
                if (!gameState.gameActive) return;
                
                // Random current burst
                if (Math.random() < 0.3) {
                    const panels = ['leftOcean', 'rightOcean'];
                    const panel = panels[Math.floor(Math.random() * panels.length)];
                    triggerCurrentBurst(panel);
                }
            }, 8000);
        }

        function triggerCurrentBurst(panelId) {
            const objects = document.querySelectorAll(`#${panelId} .game-object`);
            const burstDistance = (Math.random() - 0.5) * 100;
            
            objects.forEach(obj => {
                if (obj.physics) {
                    obj.physics.vx += (Math.random() - 0.5) * 0.006;
                    obj.physics.vy += (Math.random() - 0.5) * 0.004;
                }
                
                obj.style.setProperty('--burst-distance', burstDistance + 'px');
                obj.classList.add('current-burst');
                
                setTimeout(() => {
                    obj.classList.remove('current-burst');
                }, 2000);
            });
        }

        function updateLeaderboard() {
            const leftPlayer = gameState.currentPlayers.left;
            const rightPlayer = gameState.currentPlayers.right;
            
            // Update or add players to leaderboard
            updatePlayerScore(leftPlayer, gameState.playerScores.left);
            updatePlayerScore(rightPlayer, gameState.playerScores.right);
            
            // Sort leaderboard
            gameState.leaderboard.sort((a, b) => b.totalScore - a.totalScore);
            
            // Save to localStorage
            localStorage.setItem('oceanCleanupLeaderboard', JSON.stringify(gameState.leaderboard));
        }

        function updatePlayerScore(playerName, score) {
            let player = gameState.leaderboard.find(p => p.name === playerName);
            if (player) {
                player.totalScore += score;
                player.gamesPlayed++;
            } else {
                gameState.leaderboard.push({
                    name: playerName,
                    totalScore: score,
                    gamesPlayed: 1
                });
            }
        }

        function showResults() {
            const winner = gameState.scores.left > gameState.scores.right ? 
                            gameState.currentPlayers.left : 
                            gameState.scores.right > gameState.scores.left ?
                            gameState.currentPlayers.right : 'Tie';
            
            const resultsHTML = `
                <h3>第${gameState.roundNumber}轮结果 / Round ${gameState.roundNumber} Results</h3>
                <div class="leaderboard-item">
                    <span>${gameState.currentPlayers.left.split(' / ')[0]}</span>
                    <span>${gameState.scores.left} 分 / points</span>
                </div>
                <div class="leaderboard-item">
                    <span>${gameState.currentPlayers.right.split(' / ')[0]}</span>
                    <span>${gameState.scores.right} 分 / points</span>
                </div>
                <h3 style="margin-top: 20px; color: #4CAF50;">
                    ${winner === 'Tie' ? "平局! / It's a tie!" : `获胜者: ${winner.split(' / ')[0]}! / Winner: ${winner.split(' / ')[0]}!`}
                </h3>
                <p style="margin-top: 15px; font-size: 14px; color: #666;">
                    ${gameState.remainingPlayers.length >= 2 ? 
                        `下一轮将在5秒后开始... / Next round starts in 5 seconds... (${gameState.remainingPlayers.length} players remaining)` : 
                        '准备最终结果... / Preparing final results...'}
                </p>
            `;
            
            document.getElementById('roundResults').innerHTML = resultsHTML;
            
            // Update leaderboard display
            const leaderboardHTML = gameState.leaderboard.slice(0, 5).map((player, index) => `
                <div class="leaderboard-item">
                    <span>#${index + 1} ${player.name.split(' / ')[0]}</span>
                    <span>${player.totalScore} pts (${player.gamesPlayed} games)</span>
                </div>
            `).join('');
            
            document.getElementById('leaderboardList').innerHTML = leaderboardHTML;
            
            // Show modal
            document.getElementById('resultsModal').style.display = 'flex';
            
            // Add celebration confetti
            createConfetti(document.getElementById('resultsModal'), 40);
            
            // Chinese voice recap
            if (gameState.audioEnabled) {
                setTimeout(() => {
                    const leftName = gameState.currentPlayers.left.split(' / ')[0];
                    const rightName = gameState.currentPlayers.right.split(' / ')[0];
                    const leftScore = gameState.scores.left;
                    const rightScore = gameState.scores.right;
                    
                    speakChinese(`第${gameState.roundNumber}轮结束。左队${leftName}得分${leftScore}分`);
                    setTimeout(() => {
                        speakChinese(`右队${rightName}得分${rightScore}分`);
                        setTimeout(() => {
                            if (winner === 'Tie') {
                                speakChinese('本轮平局');
                            } else {
                                const winnerName = winner.split(' / ')[0];
                                speakChinese(`获胜者是${winnerName}`);
                            }
                        }, 2500);
                    }, 2500);
                }, 1000);
            }
            
            // Auto-advance to next round or final results
            setTimeout(() => {
                document.getElementById('resultsModal').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'none';
                
                // Clear ocean panels
                document.querySelectorAll('.game-object').forEach(obj => {
                    obj.parentNode.removeChild(obj);
                });
                
                // Reset timer display
                document.getElementById('gameTimer').classList.remove('warning', 'critical');
                
                // Check if tournament is complete
                if (gameState.remainingPlayers.length < 2) {
                    showFinalResults();
                } else {
                    // Increment round number and select next players
                    gameState.roundNumber++;
                    selectNextPlayers();
                }
            }, 5000);
        }

        function speak(text, voiceName) {
            if (!gameState.audioEnabled) return;
            
            const utterance = new SpeechSynthesisUtterance(text);
            const voices = speechSynthesis.getVoices();
            const voice = voices.find(v => v.name.includes(voiceName));
            
            if (voice) {
                utterance.voice = voice;
            }
            
            utterance.rate = 0.9;
            speechSynthesis.speak(utterance);
        }

        function speakWithFallback(text, voiceName) {
            if (!gameState.audioEnabled) return;
            
            try {
                const utterance = new SpeechSynthesisUtterance(text);
                const voices = speechSynthesis.getVoices();
                
                // Enhanced voice selection with Neural voices priority
                let voice = null;
                
                if (voiceName === 'Ava') {
                    voice = voices.find(v => 
                        v.name.includes('en-US-AvaNeural') ||
                        v.name.includes('en-US-AvaMultilingualNeural') ||
                        v.name.includes('Ava') ||
                        v.name.includes('en-US-JennyNeural') ||
                        v.name.includes('en-US-AriaNeural') ||
                        (v.lang.startsWith('en-US') && v.name.includes('Neural') && v.name.includes('Female'))
                    );
                } else if (voiceName === 'Andrew') {
                    voice = voices.find(v => 
                        v.name.includes('en-US-AndrewNeural') ||
                        v.name.includes('en-US-AndrewMultilingualNeural') ||
                        v.name.includes('Andrew') ||
                        v.name.includes('en-US-BrianNeural') ||
                        v.name.includes('en-US-ChristopherNeural') ||
                        v.name.includes('en-US-EricNeural') ||
                        v.name.includes('en-US-GuyNeural') ||
                        (v.lang.startsWith('en-US') && v.name.includes('Neural') && v.name.includes('Male'))
                    );
                } else {
                    // Generic voice search
                    voice = voices.find(v => v.name.includes(voiceName));
                }
                
                // Fallback to any high-quality English voice if preferred not found
                if (!voice) {
                    voice = voices.find(v => 
                        (v.lang.startsWith('en-US') && v.name.includes('Neural')) ||
                        (v.lang.startsWith('en') && v.name.includes('Neural')) ||
                        v.lang.startsWith('en-US') ||
                        v.lang.startsWith('en')
                    );
                }
                
                if (voice) {
                    utterance.voice = voice;
                    console.log('Using English voice:', voice.name);
                }
                
                utterance.rate = 0.9;
                
                // Error handling for TTS failures
                utterance.onerror = (event) => {
                    console.warn('TTS Error:', event.error);
                    showTTSWarning();
                    showCaptionFallback(text);
                };
                
                utterance.onend = () => {
                    hideTTSWarning();
                };
                
                speechSynthesis.speak(utterance);
                
            } catch (error) {
                console.warn('TTS not available:', error);
                showTTSWarning();
                showCaptionFallback(text);
            }
        }

        function showTTSWarning() {
            let warning = document.getElementById('ttsWarning');
            if (!warning) {
                warning = document.createElement('div');
                warning.id = 'ttsWarning';
                warning.innerHTML = '🔇';
                warning.style.cssText = `
                    position: fixed;
                    top: 50px;
                    right: 50px;
                    background: rgba(255, 193, 7, 0.9);
                    color: white;
                    padding: 8px;
                    border-radius: 50%;
                    font-size: 16px;
                    z-index: 1002;
                    animation: fadeIn 0.3s ease;
                `;
                document.body.appendChild(warning);
            }
            warning.style.display = 'block';
        }

        function hideTTSWarning() {
            const warning = document.getElementById('ttsWarning');
            if (warning) {
                warning.style.display = 'none';
            }
        }

        function showCaptionFallback(text) {
            const caption = document.createElement('div');
            caption.textContent = text;
            caption.style.cssText = `
                position: fixed;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 20px;
                font-size: 16px;
                z-index: 1001;
                animation: captionFade 3s ease-out forwards;
                max-width: 80%;
                text-align: center;
            `;
            
            // Add caption animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes captionFade {
                    0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                    20% { opacity: 1; transform: translateX(-50%) translateY(0px); }
                    80% { opacity: 1; transform: translateX(-50%) translateY(0px); }
                    100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                }
            `;
            if (!document.getElementById('captionStyle')) {
                style.id = 'captionStyle';
                document.head.appendChild(style);
            }
            
            document.body.appendChild(caption);
            
            setTimeout(() => {
                if (caption.parentNode) {
                    caption.parentNode.removeChild(caption);
                }
            }, 3000);
        }

        // Game Controls (now automatic)

        function showFinalResults() {
            const finalHTML = `
                <h2>🏆 锦标赛结束! / Tournament Complete!</h2>
                <h3>最终排行榜 / Final Leaderboard</h3>
                <div class="leaderboard">
                    ${gameState.leaderboard.slice(0, 10).map((player, index) => `
                        <div class="leaderboard-item" style="background: ${index < 3 ? '#FFD700' : '#f0f0f0'};">
                            <span>${index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `#${index + 1}`} ${player.name.split(' / ')[0]}</span>
                            <span>${player.totalScore} 总分 / total pts</span>
                        </div>
                    `).join('')}
                </div>
                <p style="margin-top: 20px; font-size: 16px; color: #4CAF50;">
                    🎉 恭喜所有参赛者! / Congratulations to all participants! 🎉
                </p>
                <p style="margin-top: 10px; font-size: 14px; color: #666;">
                    刷新页面开始新的锦标赛 / Refresh page to start a new tournament
                </p>
            `;
            
            document.getElementById('roundResults').innerHTML = finalHTML;
            document.getElementById('leaderboardList').innerHTML = '';
            document.getElementById('resultsModal').style.display = 'flex';
            
            // Announce champion in Chinese
            if (gameState.audioEnabled && gameState.leaderboard.length > 0) {
                const champion = gameState.leaderboard[0].name.split(' / ')[0];
                setTimeout(() => {
                    speakChinese(`锦标赛结束！冠军是${champion}！`);
                }, 1000);
            }
            
            // Extra confetti for final results
            createConfetti(document.getElementById('resultsModal'), 60);
        }





        // Initialize on load
        window.addEventListener('load', init);
        
        // Handle voices loading
        speechSynthesis.addEventListener('voiceschanged', () => {
            // Voices are now loaded
        });
    </script>
</body>
</html>
